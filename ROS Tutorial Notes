9.11.16

---1.2 Navigating the ROS Filesystem---
$ rospack find [package_name] //find [pack]age
$ roscd [locationname[/subdir]] //cd navigate  directly to the package
$ roscd log //check log
$ rosls [locationname[/subdir]] //ls the ros package


9.13.16
---1.3 Creating a ROS Package---
Catkin Package requirements
	i) Contain catkin compliant package.xml file
	ii) Package must contain CMakeLists.txt which uses catkin.
	iii) There can be no more than one package in each folder (no nested packages nor multiple packages sharing the same directory.

Usually work with catkin packages in catkin workspace

catkin_create_pkg <package_name> [depend1] [depend2] [depend3] //dependencies

---1.4 Building a ROS Package---
catkin_create_pkg creates package, but you need to call catkin_make to build it

with catkin_make, there are autogenerated build, devel, src folders. Build folder is default location of build space and where cmake/make are called to configure and build your packages. Devel is where executables and libraries go before you install your packages


---1.5 Understanding ROS Nodes---
Nodes-executable that uses ROS to communicate with other nodes
Messages-ROS data type used when subscribing or publishing to a topic
Topics-Nodes can publish mesages to a topic as well as subscribe to a topic to receive messages
Master-name service for ROS (helps nodes find each other)
rosout: stdout/stderr equivalent
roscore: Master + rosout + parameter server

$ rosrun [package_name] [node_name] //allows you to use the package name to directly run a node within a package without needing to know the package path

roscore = ros+core : master (provides name service for ROS) + rosout (stdout/stderr) + parameter server (parameter server will be introduced later)

rosnode = ros+node : ROS tool to get information about a node.

rosrun = ros+run : runs a node from a given package. 


---1.6 Understanding ROS Topics---
turtlesim_node and turtle_teleop_key node allow the turtle to move along screen==>communicating over ROS Topic.
turtle_teleop_key is publishing the key strokes on a topic, while turtlesim subscribes to the same topic to receive the key strokes.

rostopic -h //allows you to get help options for subcommands for rostopic


In order for subscribe/publish, the type of message has to be the same. Use "rostopic type [topic] to check

rostopic pub [topic] [msg_type] [args] //publishes data on to a topic currently advertised

---1.7 Understanding ROS Services and Parameters---
rosservice list         print information about active services
rosservice call         call the service with the provided args
rosservice type         print service type
rosservice find         find services by service type
rosservice uri          print service ROSRPC uri

dump params to a file for later use or to load them
rosparam dump [file_name] [namespace]
rosparam load [file_name] [namespace]

---1.8 Using rqt_console and roslaunch---
rqt_console acts as debugger/rqt_logger_level decides what level of bugs you want to see
roslaunch [package] [filename.launch] //starts nodes as defined in a launch file

---1.9 Using rosed to edit files in ROS---
rosed [package_name] [filename]
can use rosed package_name] <tab><tab> to see files in package. Helps if you don't really know which file or what package

---1.10 Creating a ROS msg and srv---
msg: msg files are simple text files that describe the fields of a ROS message. They are used to generate source code for messages in different languages
srv: an srv file describes a service. It is composed of two parts: a request and a response.

rosmsg show info about messages
rossrv show info about service

add dependencies
make sure to uncomment generate_messages
uncomment message_generation and message_runtime in package.xml.

---1.12 Writing a Simple Publisher and Subscriber---
Look at the code we downloaded

---1.13 Examining the Simple Publisher and Subscriber---
Just showing the subscriber and publisher running

---1.15 Writing a Simple Service and Client (Python)---
Run through of what is in the code.

---1.16 Examing the Simple Service and Client---
Nothing much just running client and server

---1.17 Recording and playing back data---

Use rosbag record to keep history of publishing/subscribing

---1.18 Troubleshoot with roswtf---
General pointers for roswtf

---1.19 Navigating the ROS wiki---
not much

---1.20 where Next?---
Tips on sims and nice packages

********1.2 Intermediate Level********
---1.1 Creating a RO package by hand---
mkdir -p src/foobar
cd src/foobar
==> add a manifest.xml file
<package>
  <name>foobar</name>
  <version>1.2.4</version>
  <description>
  This package provides foo capability.
  </description>
  <maintainer email="foobar@foo.bar.willowgarage.com">PR-foobar</maintainer>
  <license>BSD</license>

  <buildtool_depend>catkin</buildtool_depend>

  <build_depend>roscpp</build_depend>
  <build_depend>std_msgs</build_depend>

  <run_depend>roscpp</run_depend>
  <run_depend>std_msgs</run_depend>
</package>

==>Try rospack find foobar
==>foobar/CMakeLists.txt put 
cmake_minimum_required(VERSION 2.8.3)
project(foobar)
find_package(catkin REQUIRED roscpp std_msgs)
catkin_package()

==>Package completed

---1.2 Managing System Dependencies---
rosdep install turtlesim (helps you install dependencies)

---1.3 Roslaunch tips for large projects---
Launch file general code 
<launch>
  <group name="wg">
    <include file="$(find pr2_alpha)/$(env ROBOT).machine" />
    <include file="$(find 2dnav_pr2)/config/new_amcl_node.xml" />
    <include file="$(find 2dnav_pr2)/config/base_odom_teleop.xml" />
    <include file="$(find 2dnav_pr2)/config/lasers_and_filters.xml" />
    <include file="$(find 2dnav_pr2)/config/map_server.xml" />
    <include file="$(find 2dnav_pr2)/config/ground_plane.xml" />

    <!-- The navigation stack and associated parameters -->
    <include file="$(find 2dnav_pr2)/move_base/move_base.xml" />
  </group>
</launch>

---1.4 Running ROS across multiple machines---
-Well-written node makes no assumptions about where in network it runs
Things to keep in mind:
-You only need one master. Select one machine to run it on
-All nodes must be configured to use the same master, via ROS_MASTER_URI
-There must be complete, bi-directional connectivity between all pairs of machines, on all ports
-Each machine must advertise itself by a name that all other machines can resolve
-remember to call "export ROS_MASTER_URI=http://hal:11311" for both listener and talker

---1.5 Defining Custom Messages---
Place a .msg file inside the msg directory in a package

from std_msgs.msg import String

msg = String()

---1.6 Using a C++ class in Python---
Essentially translating wrappers


STEP 2: ROSPY TUTORIALS
---1.3 Using Parameters in rospy---
# get a global parameter
rospy.get_param('/global_param_name')

# get a parameter from our parent namespace
rospy.get_param('param_name')

# get a parameter from our private namespace
rospy.get_param('~private_param_name')

rospy.set_param(param_name, param_value): 

rospy.delete_param('param_name')

rospy.resolve_name(name) to help debug and figure out your Node's namespace.

full_param_name = rospy.search_param('foo')
param_value = rospy.get_param(full_param_name)


---1.4 Logging with rospy---
rospy.logdebug(msg, *args)
rospy.logwarn(msg, *args)
rospy.loginfo(msg, *args)
rospy.logerr(msg, *args)
rospy.logfatal(msg, *args)

Depending on verbosity level:
-stdout: loginfo
-stderr: logerr, logfatal, logwarn (ROS 0.9)
-your Node's log file: all
-the /rosout Topic: loginfo, logwarn, logerr, logfatal 

rospy.init_node('my_node', log_level=rospy.DEBUG) to see lodgebug messages on /rosout

---1.5 Writing a ROS Python Makefile---
<buildtool_depend>catkin</buildtool_depend> in package.xml

catkin_create_pkg my_pkg message_generation rospy
(dependency on message_generation and rospy)

include dependency of message_generation in package.xml.

cmake_minimum_required(VERSION 2.8.3)
project(my_pkg)

find_package(catkin REQUIRED COMPONENTS message_generation rospy)

add_message_files(
  FILES  # e.g. Floats.msg HeaderString.msg
)
add_service_files(
  DIRECTORY srv 
  FILES AddTwoInts.srv BadTwoInts.srv
)

## Generate services in the 'srv' folder
# add_service_files(
#  FILES  # e.g. Floats.srv HeaderString.srv
#)

## Generate added messages and services with any dependencies
generate_messages()

catkin_package(
  CATKIN_DEPENDS message_runtime
)

---1.6 Settuping Up Your PYTHONPATH---
Catkin sets up PYTHONPATH in your catkin workspace and some relay files so that this works even with two python modules in your src folder. So if you have two modules in your catkin workspace, where one depends on the other, you need to configure and build the modules first, and then you can run them. 

You just need to call import [library/package]

#!/usr/bin/env python
import beginner_tutorials.msg
num = beginner_tutorials.msg.Num()
print(num)

STEP 3
---1.1 Writing a Simple Action Server using the Execute Callback---

Figuring out goal/result/feedback messages
#goal definition
int32 order
---
#result definition
int32[] sequence
---
#feedback
int32[] sequence

find_package(catkin REQUIRED COMPONENTS actionlib_msgs) to CMakeLists.txt

add_action_files(
	DIRECTORY action
	FILES Fibonacci.action
) //declare actions you want to be generated

generate_messages(
	DEPENDENCIES actionlib_msgs std_msgs
) //make sure to declare dependency on actionlib_msgs/std_msgs

catkin_package(
	CATKIN_DEPENDS actionlib_msgs
) //add actionlib_msgs to catkin_package

Server Code:
#include <ros/ros.h>
#include <actionlib/server/simple_action_server.h>
#include <learning_actionlib/FibonacciAction.h>

class FibonacciAction
{
protected:

  ros::NodeHandle nh_;
  // NodeHandle instance must be created before this line. Otherwise strange error may occur.
  actionlib::SimpleActionServer<learning_actionlib::FibonacciAction> as_; 
  std::string action_name_;
  // create messages that are used to published feedback/result
  learning_actionlib::FibonacciFeedback feedback_;
  learning_actionlib::FibonacciResult result_;

public:

  FibonacciAction(std::string name) :
    as_(nh_, name, boost::bind(&FibonacciAction::executeCB, this, _1), false),
    action_name_(name)
  {
    as_.start();
  }

  ~FibonacciAction(void)
  {
  }

  void executeCB(const learning_actionlib::FibonacciGoalConstPtr &goal)
  {
    // helper variables
    ros::Rate r(1);
    bool success = true;

    // push_back the seeds for the fibonacci sequence
    feedback_.sequence.clear();
    feedback_.sequence.push_back(0);
    feedback_.sequence.push_back(1);

    // publish info to the console for the user
    ROS_INFO("%s: Executing, creating fibonacci sequence of order %i with seeds %i, %i", action_name_.c_str(), goal->order, feedback_.sequence[0], feedback_.sequence[1]);

    // start executing the action
    for(int i=1; i<=goal->order; i++)
    {
      // check that preempt has not been requested by the client
      if (as_.isPreemptRequested() || !ros::ok())
      {
        ROS_INFO("%s: Preempted", action_name_.c_str());
        // set the action state to preempted
        as_.setPreempted();
        success = false;
        break;
      }
      feedback_.sequence.push_back(feedback_.sequence[i] + feedback_.sequence[i-1]);
      // publish the feedback
      as_.publishFeedback(feedback_);
      // this sleep is not necessary, the sequence is computed at 1 Hz for demonstration purposes
      r.sleep();
    }

    if(success)
    {
      result_.sequence = feedback_.sequence;
      ROS_INFO("%s: Succeeded", action_name_.c_str());
      // set the action state to succeeded
      as_.setSucceeded(result_);
    }
  }


};


int main(int argc, char** argv)
{
  ros::init(argc, argv, "fibonacci");

  FibonacciAction fibonacci(ros::this_node::getName());
  ros::spin();

  return 0;
}

For CMakeLists.txt file, add:
add_executable(fibonacci_server src/fibonacci_server.cpp)

target_link_libraries(
  fibonacci_server
  ${catkin_LIBRARIES}
)

add_dependencies(
  fibonacci_server
  ${learning_actionlib_EXPORTED_TARGETS}
)


---1.2 Writing a Simple Action Client---

Client Code:
#include <ros/ros.h>
#include <actionlib/client/simple_action_client.h>
#include <actionlib/client/terminal_state.h>
#include <learning_actionlib/FibonacciAction.h>

int main (int argc, char **argv)
{
  ros::init(argc, argv, "test_fibonacci");

  // create the action client
  // true causes the client to spin its own thread
  actionlib::SimpleActionClient<learning_actionlib::FibonacciAction> ac("fibonacci", true);

  ROS_INFO("Waiting for action server to start.");
  // wait for the action server to start
  ac.waitForServer(); //will wait for infinite time

  ROS_INFO("Action server started, sending goal.");
  // send a goal to the action
  learning_actionlib::FibonacciGoal goal;
  goal.order = 20;
  ac.sendGoal(goal);

  //wait for the action to return
  bool finished_before_timeout = ac.waitForResult(ros::Duration(30.0));

  if (finished_before_timeout)
  {
    actionlib::SimpleClientGoalState state = ac.getState();
    ROS_INFO("Action finished: %s",state.toString().c_str());
  }
  else
    ROS_INFO("Action did not finish before the time out.");

  //exit
  return 0;
}

---1.3 Running an Action Client and Server---
rosrun learning_actionlib fibonacci_server //starts action server

rosrun learning_actionlib fibonacci_client //starts action client

---1.4 Writing a Simple Action Server using the Execute Callback (Python)---

#! /usr/bin/env python

import roslib; roslib.load_manifest('actionlib_tutorials')
import rospy

import actionlib

import actionlib_tutorials.msg

class FibonacciAction(object):
  # create messages that are used to publish feedback/result
  _feedback = actionlib_tutorials.msg.FibonacciFeedback()
  _result   = actionlib_tutorials.msg.FibonacciResult()

  def __init__(self, name):
    self._action_name = name
    self._as = actionlib.SimpleActionServer(self._action_name, actionlib_tutorials.msg.FibonacciAction, execute_cb=self.execute_cb, auto_start = False)
    self._as.start()
    
  def execute_cb(self, goal):
    # helper variables
    r = rospy.Rate(1)
    success = True
    
    # append the seeds for the fibonacci sequence
    self._feedback.sequence = []
    self._feedback.sequence.append(0)
    self._feedback.sequence.append(1)
    
    # publish info to the console for the user
    rospy.loginfo('%s: Executing, creating fibonacci sequence of order %i with seeds %i, %i' % (self._action_name, goal.order, self._feedback.sequence[0], self._feedback.sequence[1]))
    
    # start executing the action
    for i in xrange(1, goal.order):
      # check that preempt has not been requested by the client
      if self._as.is_preempt_requested():
        rospy.loginfo('%s: Preempted' % self._action_name)
        self._as.set_preempted()
        success = False
        break
      self._feedback.sequence.append(self._feedback.sequence[i] + self._feedback.sequence[i-1])
      # publish the feedback
      self._as.publish_feedback(self._feedback)
      # this step is not necessary, the sequence is computed at 1 Hz for demonstration purposes
      r.sleep()
      
    if success:
      self._result.sequence = self._feedback.sequence
      rospy.loginfo('%s: Succeeded' % self._action_name)
      self._as.set_succeeded(self._result)
      
if __name__ == '__main__':
  rospy.init_node('fibonacci')
  FibonacciAction(rospy.get_name())
  rospy.spin()


server code ^

---1.5 Writing a Simple Action Client (Python)---
#! /usr/bin/env python

import roslib; roslib.load_manifest('actionlib_tutorials')
import rospy

# Brings in the SimpleActionClient
import actionlib

# Brings in the messages used by the fibonacci action, including the
# goal message and the result message.
import actionlib_tutorials.msg

def fibonacci_client():
    # Creates the SimpleActionClient, passing the type of the action
    # (FibonacciAction) to the constructor.
    client = actionlib.SimpleActionClient('fibonacci', actionlib_tutorials.msg.FibonacciAction)

    # Waits until the action server has started up and started
    # listening for goals.
    client.wait_for_server()

    # Creates a goal to send to the action server.
    goal = actionlib_tutorials.msg.FibonacciGoal(order=20)

    # Sends the goal to the action server.
    client.send_goal(goal)

    # Waits for the server to finish performing the action.
    client.wait_for_result()

    # Prints out the result of executing the action
    return client.get_result()  # A FibonacciResult

if __name__ == '__main__':
    try:
        # Initializes a rospy node so that the SimpleActionClient can
        # publish and subscribe over ROS.
        rospy.init_node('fibonacci_client_py')
        result = fibonacci_client()
        print "Result:", ', '.join([str(n) for n in result.sequence])
    except rospy.ROSInterruptException:
        print "program interrupted before completion"

action client code ^

STEP 4 tf tutorials
---1.0 Introduction to tf---
Showing 2 turtles chasing each other


---1.1 Writing a tf broadcaster---
Create package first

TF BROADCASTER
#!/usr/bin/env python  
import roslib
roslib.load_manifest('learning_tf')
import rospy

import tf
import turtlesim.msg

def handle_turtle_pose(msg, turtlename):
    br = tf.TransformBroadcaster()
    br.sendTransform((msg.x, msg.y, 0),
                     tf.transformations.quaternion_from_euler(0, 0, msg.theta),
                     rospy.Time.now(),
                     turtlename,
                     "world")

if __name__ == '__main__':
    rospy.init_node('turtle_tf_broadcaster')
    turtlename = rospy.get_param('~turtle')
    rospy.Subscriber('/%s/pose' % turtlename,
                     turtlesim.msg.Pose,
                     handle_turtle_pose,
                     turtlename)
    rospy.spin()

==> chmod +x nodes/turtle_tf_broadcaster.py (to make it executable)

---1.2 Writing a tf listener---
turtle_tf_listener.py


#!/usr/bin/env python  
import roslib
roslib.load_manifest('learning_tf')
import rospy
import math
import tf
import geometry_msgs.msg
import turtlesim.srv

if __name__ == '__main__':
    rospy.init_node('tf_turtle')

    listener = tf.TransformListener()

    rospy.wait_for_service('spawn')
    spawner = rospy.ServiceProxy('spawn', turtlesim.srv.Spawn)
    spawner(4, 2, 0, 'turtle2')

    turtle_vel = rospy.Publisher('turtle2/cmd_vel', geometry_msgs.msg.Twist,queue_size=1)

    rate = rospy.Rate(10.0)
    while not rospy.is_shutdown():
        try:
            (trans,rot) = listener.lookupTransform('/turtle2', '/turtle1', rospy.Time(0))
        except (tf.LookupException, tf.ConnectivityException, tf.ExtrapolationException):
            continue

        angular = 4 * math.atan2(trans[1], trans[0])
        linear = 0.5 * math.sqrt(trans[0] ** 2 + trans[1] ** 2)
        cmd = geometry_msgs.msg.Twist()
        cmd.linear.x = linear
        cmd.angular.z = angular
        turtle_vel.publish(cmd)

        rate.sleep()


Interesting code:
(trans,rot) = listener.lookupTransform('/turtle2', '/turtle1', rospy.Time(0))

//lookupTransform takes a) transform from this frame b) ...to this frame c) time which we want to transform

---1.3 Adding a frame---
You want relative positions ==> local frames

fixed_tf_broadcaster.py
#!/usr/bin/env python  
import roslib
roslib.load_manifest('learning_tf')

import rospy
import tf

if __name__ == '__main__':
    rospy.init_node('my_tf_broadcaster')
    br = tf.TransformBroadcaster()
    rate = rospy.Rate(10.0)
    while not rospy.is_shutdown():
        br.sendTransform((0.0, 2.0, 0.0),
                         (0.0, 0.0, 0.0, 1.0),
                         rospy.Time.now(),
                         "carrot1",
                         "turtle1")
        rate.sleep()


